# 5월 2주차 문제
1. [도넛과 막대그래프](https://school.programmers.co.kr/learn/courses/30/lessons/258711)
2. [산모양 타일링](https://school.programmers.co.kr/learn/courses/30/lessons/258705)


## 도넛과 막대그래프
- 도넛 모양 그래프
  - `n`개의 정점
  - `n`개의 간선
  - 아무 정점에서 출발해서 사용한 적 없는 간선을 타고가면 출발 정점으로 복귀
- 막대 모양 그래프
  - `n`개의 정점
  - `n - 1`개의 간선
- 8자 모양 그래프
  - `2n + 1`개의 정점
  - `2n + 2`개의 간선
  - 크기가 동일한 2개의 도넛 모양 그래프에서 정점을 하나씩 골라 결합
  - `n + 1` 도넛 모양 그래프를 2개 결합. 정점 1개를 합쳐서.

### 요구
- 생성한 정점의 번호
- 정점을 생성하기 전 도넛 모양 그래프의 수, 막대 모양 그래프의 수, 8자 모양 그래프의 수

### 풀이
- 그래프를 만든다.
- 그래프를 만들면서 `[start, end]` 구조에서 `end`에 한 번도 안들어온 값이 새로만든 정점 K
- K 정점에서 각 노드를 탐색해서 그래프 형태 파악
  - 정점에 연결된 간선이 1개 초과이면? 8자
  - start 정점으로 돌아왔으면? 도넛
  - 더이상 갈 정점이 없으면? 막대
- -> 절반 이상 에러... 왤까..?
  - start는 2개 이상인, end에 값이 없는 정점이 K임. 막대 그래프 중간부터 시작하는 경우, 막대그래프의 시작 정점은 end 호출되지 않음


---
## 산모양 타일링
- 상단 없을 경우
  - n 이 1씩 늘어날 때마다 경우의 수 증가
  - 정삼각형만 사용하는 경우 : 이전 case 수만큼 증가
  - 마를모 : 이전 case 수만큼 중가
  - 마를모 + 정삼각 : 이전 case와 겹치는 부분 제외하고 증가
    - n - 1 만큼 증가시키고 n - 2만큼 빼주면 된다
    - 겸치는 부분은 마름모로 사용된다.
    - n - 2 case에 붙이는 경우와 같음
    - n - 2 case 를 빼주어야 new case와 중복되지 않음
- 상단 있을 경우
  - 위와 동일하나, 상단 마름모 case 추가된다.

- 점화식 : dp[n] = dp[n - 1] * (!hasTop ? 3 : 4) - dp[n - 2]
- dp[0] = 1
- dp[1] = !hasTop ? 3 : 4


